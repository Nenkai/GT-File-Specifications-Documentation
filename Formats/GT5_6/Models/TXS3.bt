//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: TXS3 Gran Turismo Image Header Specifics
//   Authors: Nenkai#9075
//   Version: 1.0
//   Purpose: Texture Files
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef enum <ubyte> 
{
    CELL_GCM_TEXTURE_B8						= 0x81,
	CELL_GCM_TEXTURE_A1R5G5B5				= 0x82,
	CELL_GCM_TEXTURE_A4R4G4B4				= 0x83,
	CELL_GCM_TEXTURE_R5G6B5					= 0x84,
	CELL_GCM_TEXTURE_A8R8G8B8				= 0x85,
	CELL_GCM_TEXTURE_COMPRESSED_DXT1		= 0x86,
	CELL_GCM_TEXTURE_COMPRESSED_DXT23		= 0x87,
	CELL_GCM_TEXTURE_COMPRESSED_DXT45		= 0x88,
	CELL_GCM_TEXTURE_G8B8					= 0x8B,
	CELL_GCM_TEXTURE_R6G5B5					= 0x8F,
	CELL_GCM_TEXTURE_DEPTH24_D8				= 0x90,
	CELL_GCM_TEXTURE_DEPTH24_D8_FLOAT		= 0x91,
	CELL_GCM_TEXTURE_DEPTH16				= 0x92,
	CELL_GCM_TEXTURE_DEPTH16_FLOAT			= 0x93,
	CELL_GCM_TEXTURE_X16					= 0x94,
	CELL_GCM_TEXTURE_Y16_X16				= 0x95,
	CELL_GCM_TEXTURE_R5G5B5A1				= 0x97,
	CELL_GCM_TEXTURE_COMPRESSED_HILO8		= 0x98,
	CELL_GCM_TEXTURE_COMPRESSED_HILO_S8		= 0x99,
	CELL_GCM_TEXTURE_W16_Z16_Y16_X16_FLOAT	= 0x9A,
	CELL_GCM_TEXTURE_W32_Z32_Y32_X32_FLOAT	= 0x9B,
	CELL_GCM_TEXTURE_X32_FLOAT				= 0x9C,
	CELL_GCM_TEXTURE_D1R5G5B5				= 0x9D,
	CELL_GCM_TEXTURE_D8R8G8B8				= 0x9E,
	CELL_GCM_TEXTURE_Y16_X16_FLOAT			= 0x9F,
	CELL_GCM_TEXTURE_COMPRESSED_B8R8_G8R8	= 0xAD,
	CELL_GCM_TEXTURE_COMPRESSED_R8B8_R8G8	= 0xAE,
} CELL_GCM_TEXTURE_FORMAT;

typedef enum <byte>
{
  CELL_GCM_TEXTURE_CONVOLUTION_NONE,
  CELL_GCM_TEXTURE_CONVOLUTION_QUINCUNX,
  CELL_GCM_TEXTURE_CONVOLUTION_GAUSSIAN,
  CELL_GCM_TEXTURE_CONVOLUTION_QUINCUNX_ALT,

} CELL_GCM_TEXTURE_CONVOLUTION;

typedef enum <byte>
{
  CELL_GCM_TEXTURE_MIN_NONE,
  CELL_GCM_TEXTURE_NEAREST,
  CELL_GCM_TEXTURE_LINEAR,
  CELL_GCM_TEXTURE_NEAREST_NEAREST,
  CELL_GCM_TEXTURE_LINEAR_NEAREST,
  CELL_GCM_TEXTURE_NEAREST_LINEAR,
  CELL_GCM_TEXTURE_LINEAR_LINEAR,
  CELL_GCM_TEXTURE_CONVOLUTION_MIN ,
} CELL_GCM_TEXTURE_MIN;

typedef enum <byte>
{
  CELL_GCM_TEXTURE_MAG_NONE,
  CELL_GCM_TEXTURE_NEAREST_MAG,
  CELL_GCM_TEXTURE_LINEAR_MAG,
  CELL_GCM_TEXTURE_CONVOLUTION_MAG,
} CELL_GCM_TEXTURE_MAG;

typedef enum <byte>
{
   CELL_GCM_TEXTURE_WRAP_NONE,
   CELL_GCM_TEXTURE_WRAP,
   CELL_GCM_TEXTURE_MIRROR,
   CELL_GCM_TEXTURE_CLAMP_TO_EDGE,
   CELL_GCM_TEXTURE_BORDER,
   CELL_GCM_TEXTURE_CLAMP,
   CELL_GCM_TEXTURE_MIRROR_ONCE_CLAMP_TO_EDGE,
   CELL_GCM_TEXTURE_MIRROR_ONCE_BORDER,
   CELL_GCM_TEXTURE_MIRROR_ONCE_CLAMP,
} CELL_GCM_TEXTURE_WRAP;

typedef enum <byte>
{
  	CELL_GCM_TEXTURE_MAX_ANISO_1	= (0),
	CELL_GCM_TEXTURE_MAX_ANISO_2	= (1),
	CELL_GCM_TEXTURE_MAX_ANISO_4	= (2),
	CELL_GCM_TEXTURE_MAX_ANISO_6	= (3),
	CELL_GCM_TEXTURE_MAX_ANISO_8	= (4),
	CELL_GCM_TEXTURE_MAX_ANISO_10	= (5),
	CELL_GCM_TEXTURE_MAX_ANISO_12	= (6),
	CELL_GCM_TEXTURE_MAX_ANISO_16	= (7),
} CELL_GCM_TEXTURE_MAX_ANISO;

typedef enum <byte>
{
    CELL_GCM_LOCATION_LOCAL = 0,
    CELL_GCM_LOCATION_MAIN = 1,
} CELL_GCM_LOCATION;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_DIMENSION_1 = 1,
    CELL_GCM_TEXTURE_DIMENSION_2 = 2,
    CELL_GCM_TEXTURE_DIMENSION_3 = 3
} CELL_GCM_TEXTURE_DIMENSION;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_ZFUNC_NEVER	= 0,
	CELL_GCM_TEXTURE_ZFUNC_LESS		= 1,
	CELL_GCM_TEXTURE_ZFUNC_EQUAL	= 2,
	CELL_GCM_TEXTURE_ZFUNC_LEQUAL	= 3,
	CELL_GCM_TEXTURE_ZFUNC_GREATER	= 4,
	CELL_GCM_TEXTURE_ZFUNC_NOTEQUAL	= 5,
	CELL_GCM_TEXTURE_ZFUNC_GEQUAL	= 6,
	CELL_GCM_TEXTURE_ZFUNC_ALWAYS	= 7,
} CELL_GCM_TEXTURE_ZFUNC;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_BORDER_TEXTURE = 0,
    CELL_GCM_TEXTURE_BORDER_COLOR = 1,
} CELL_GCM_TEXTURE_BORDER;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_UNSIGNED_REMAP_NORMAL,
    CELL_GCM_TEXTURE_UNSIGNED_REMAP_BIASED,
} CELL_GCM_TEXTURE_UNSIGNED_REMAP;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_REMAP_FROM_A = 0,
	CELL_GCM_TEXTURE_REMAP_FROM_R = 1,
	CELL_GCM_TEXTURE_REMAP_FROM_G = 2,
	CELL_GCM_TEXTURE_REMAP_FROM_B = 3,
} CELL_GCM_TEXTURE_REMAP_FROM;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_REMAP_ORDER_XYXY = 0,
    CELL_GCM_TEXTURE_REMAP_ORDER_XXXY = 1,
} CELL_GCM_TEXTURE_REMAP_ORDER;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_REMAP_ZERO,
    CELL_GCM_TEXTURE_REMAP_ONE,
    CELL_GCM_TEXTURE_REMAP_REMAP,
} CELL_GCM_TEXTURE_REMAP_OUT;

typedef enum <byte>
{
    CELL_GCM_FALSE = 0,
    CELL_GCM_TRUE = 1,
} CELL_GCM_BOOL;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_ISO_LOW,
    CELL_GCM_TEXTURE_ISO_HIGH,
} CELL_GCM_TEXTURE_ISO;

typedef enum <byte>
{
    CELL_GCM_TEXTURE_ANISO_LOW,
    CELL_GCM_TEXTURE_ANISO_HIGH,
} CELL_GCM_TEXTURE_ANISO;

string PrintFormat(ubyte& format)
{
    string str = "";
    local CELL_GCM_TEXTURE_FORMAT actualFormat = format & 0b10011111;
    SPrintf(str, "%s (0x%x)", EnumToString(actualFormat), actualFormat);

    local int bit = (format >> 5) & 1;
    str += bit != 0 ? " - CELL_GCM_TEXTURE_LN (Bit 6)" : " - CELL_GCM_TEXTURE_SZ (Bit 6)";

    bit = (format >> 6) & 1;
    str += bit != 0 ? " - CELL_GCM_TEXTURE_UN (Bit 5)" : " - CELL_GCM_TEXTURE_NR (Bit 5)";
    return str;
}

typedef struct 
{
    BitfieldDisablePadding();
    struct
    {
        uint offset <format=hex, comment="Normally CELL_GCM_NV4097_SET_TEXTURE_OFFSET aka 0x1A00 + (index * 0x20)">;
    } CELL_GCM_METHOD_HEADER_TEXTURE_OFFSET;

    // CELL_GCM_METHOD_DATA_TEXTURE_OFFSET
    struct
    {
        uint offset <format=hex>;
    } CELL_GCM_METHOD_DATA_TEXTURE_OFFSET;

    struct
    {
        byte pad;
        byte mipmap;
        ubyte format : 8 <comment=PrintFormat>;
        CELL_GCM_TEXTURE_DIMENSION dimension : 4;
        CELL_GCM_TEXTURE_BORDER border : 1;
        CELL_GCM_BOOL cubemap : 1 <comment="whether cube map is enabled">;
        CELL_GCM_LOCATION location : 2 <comment="Remove 1. fragment program location, 0 = local memory, 1 = main memory">;
    } CELL_GCM_METHOD_DATA_TEXTURE_BORDER_FORMAT;

    struct
    {
        CELL_GCM_TEXTURE_ZFUNC zfunc : 4;
        byte gamma : 8;
        CELL_GCM_TEXTURE_WRAP wrap_r : 4;
        CELL_GCM_TEXTURE_UNSIGNED_REMAP unsignedRemap : 4;
        CELL_GCM_TEXTURE_WRAP wrap_t : 4 <comment="adjustment when the T coordinate exceeds the texture size">;
        byte anisoBias : 4;
        CELL_GCM_TEXTURE_WRAP wrap_s : 4 <comment="adjustment when the S coordinate exceeds the texture size">;
    } CELL_GCM_METHOD_DATA_TEXTURE_ADDRESS;

    struct
    {
        CELL_GCM_BOOL enable : 1 <comment="stipple polygon rendering">;
        short minlod : 12;
        short maxlod : 12;
        CELL_GCM_TEXTURE_MAX_ANISO maxAniso : 3;
        byte pad : 1;
        CELL_GCM_BOOL alphakill : 1;
        byte pad : 2;
    } CELL_GCM_METHOD_DATA_TEXTURE_CONTROL0_ALPHA_KILL;
    
    struct
    {
        int pad : 15;
        CELL_GCM_TEXTURE_REMAP_ORDER remapOrder : 1;
        CELL_GCM_TEXTURE_REMAP_OUT OutB : 2;
        CELL_GCM_TEXTURE_REMAP_OUT OutG : 2;
        CELL_GCM_TEXTURE_REMAP_OUT OutR : 2;
        CELL_GCM_TEXTURE_REMAP_OUT OutA : 2;
        CELL_GCM_TEXTURE_REMAP_FROM InB : 2;
        CELL_GCM_TEXTURE_REMAP_FROM InG : 2;
        CELL_GCM_TEXTURE_REMAP_FROM InR : 2;
        CELL_GCM_TEXTURE_REMAP_FROM InA : 2;
    } CELL_GCM_METHOD_DATA_TEXTURE_CONTROL1;

    struct
    {
        CELL_GCM_BOOL bs : 1;
        CELL_GCM_BOOL gs : 1;
        CELL_GCM_BOOL rs : 1;
        CELL_GCM_BOOL as : 1;
        CELL_GCM_TEXTURE_MAG mag : 4 <comment="filter type for texture reduction">;
        CELL_GCM_TEXTURE_MIN min : 8 <comment="filter type for texture enlargement">;
        CELL_GCM_TEXTURE_CONVOLUTION convultion : 3 <comment="convolution filter formula">;
        short bias : 13 <comment="bias value for mipmap level in texture reductions">;
    } CELL_GCM_METHOD_DATA_TEXTURE_FILTER_SIGNED;

    struct
    {
        ushort width;
        ushort height;
    } CELL_GCM_METHOD_DATA_TEXTURE_IMAGE_RECT;

    struct
    {
        uint borderColor;
    } CELL_GCM_METHOD_DATA_TEXTURE_BORDER_COLOR;

    struct
    {
        int pad : 24;
        CELL_GCM_TEXTURE_ANISO aniso : 1;
        CELL_GCM_TEXTURE_ISO iso : 1;
        uint slope : 6;
    } CELL_GCM_METHOD_DATA_TEXTURE_CONTROL2;

    struct
    {
        uint depth : 12;
        uint pitch : 20;
    } CELL_GCM_METHOD_DATA_TEXTURE_CONTROL3;

    uint reserved0;
    uint reserved1;
    uint what6;
    uint imageID;
    uint what7;
    uint ImageNameOffset <format=hex, fgcolor=cRed>;

    local int cPos = FTell();
    if (ImageNameOffset != 0)
    {
        FSeek(ImageNameOffset);
        string ImageName <bgcolor=cGray>;
    }
    FSeek(cPos);

} PGLUTextureInfo <bgcolor=cYellow, optimize=false>;

typedef struct 
{
    int unk <format=hex, comment="Always 0">;
    int StreamOffset <format=hex, fgcolor=cRed>;
    int CompressedSize <format=hex, fgcolor=cDkGreen>;
    int UncompressedSize <format=hex, fgcolor=cGreen>;
} StreamTextureMapInfo <optimize=false, bgcolor=cDkPurple>;

typedef struct StreamTextureMapSet
{
   int StreamTextureMapOffset <format=hex>;
   int ImageInfoCount <fgcolor=cGreen>;
   int unk;
   int TotalUncompressedSetSize <format=hex>;
   short unk;
   short Width;
   short Width2;
   short unk2;
   int _pad_[2];
   
   local int cPos = FTell();
   FSeek(StreamTextureMapOffset);
   StreamTextureMapInfo streamFileInfo[ImageInfoCount];
   FSeek(cPos);
} StreamMap <bgcolor=cLtBlue, bgcolor=cPurple>;

typedef struct
{
    uint ImageOffset <format=hex, fgcolor=cRed>;
    uint ImageSize <format=hex>;
    byte _two_; // 0x20 flag when running
    ubyte ImageFormat : 8 <comment=PrintFormat>;
    byte MipmapCount;
    byte _two2_;
    ushort ImageWidth;
    ushort ImageHeight;
    ushort Unk;
    ushort Unk2;

    int pad;
    int StreamTextureMapSetOffset <format=hex, fgcolor=cRed>;
    int pad;

    local int cPos = FTell();
    if (StreamTextureMapSetOffset != 0)
    {
        FSeek(StreamTextureMapSetOffset);
        StreamMap map;
    }

    FSeek(cPos);
} ImageData <optimize=false>;

typedef struct (int arrSize)
{
    ImageData images[arrSize];
} ImageDataMap <bgcolor=cDkGreen>;

// Main header is 0x40
typedef struct
{
    char Magic[4];
    if (Magic[0] == '3')
        LittleEndian();
    else
        BigEndian();

    uint FileSize <format=hex>;
    uint BaseFilePos <format=hex>;
    uint HeaderSizeMaybe;
    uint Unk2 <comment="Related to UnkOffset">;
    ushort PGLUTextureInfoCount;
    ushort TexturemageInfoCount;
    uint PGLUTextureInfoOffset <format=hex, fgcolor=cRed>;
    uint TextureInfoOffset <format=hex, fgcolor=cRed>;

    int UnkOffset <format=hex>;

    FSeek(PGLUTextureInfoOffset);
    PGLUTextureInfo textureInfos[PGLUTextureInfoCount];

    FSeek(TextureInfoOffset);
    ImageDataMap data(TexturemageInfoCount);
} TextureSet3;