//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef struct
{
    int VertDataOffset <format=hex, fgcolor=cRed>;
    int UnkOffset0x04 <format=hex, fgcolor=cRed>;
    int UnkOffset0x08 <format=hex, fgcolor=cRed>;
    int ColorSetsOffset <format=hex, fgcolor=cRed>;
    int UnkOffset0x10 <format=hex, fgcolor=cRed>;
    int UnkOffset0x14 <format=hex, fgcolor=cRed>;
    int UnkOffset0x18 <format=hex, fgcolor=cRed>;
    int unk;
    short unk;
    short FlexVertCount;
    short unk;
    short ColorSetLen;
    short UnkTriCountMaybe;
    short SizeFor0x14 <comment="0x10 each">;
    short unk;
    short unk;

    FSeek(BasePos + UnkOffset0x18);
    int unk : 6;
    int unkk : 6;
    int padMaybe : 16;
    int faceType : 6;
    int sectOffset : 11;
    byte zoneCount : 4;
    byte b : 4;

    
    short unk_ : 16;
    short unk : 10;

    byte skip : 2;

    int unk : 9;

    byte test[SizeFor0x14 * 0x10];

    
    if (VertDataOffset != 0)
    {
        FSeek(BasePos + UnkOffset0x10);
        BitfieldDisablePadding();
        
        struct
        {
            int64 a : 1;
            int64 a : 13;
            int64 b : 13;
            int64 c : 13;
        } Test[(UnkTriCountMaybe * 3) + 21];
        FSeek(FileSize());
    }
} FlexData;

typedef struct
{
    short FlexDeclarationIndex;
    short ElementBitLayoutDefinitionIndex;
    short unk;
    byte CountOfUnk;
    byte unk;
    int UnkOffset <format=hex, fgcolor=cRed>;
    float unk;
    int DataOffset <format=hex, fgcolor=cRed>; // combine with countofunk
    int unk;

    local int i = 0;
    if (DataOffset != 0)
    {
        for (i = 0; i < CountOfUnk; i++)
        {
            FSeek(BasePos + DataOffset + (i * 0x30));
            FlexData Data;
        }
    }
} FlexInfoAndData;

typedef struct
{
    int TotalBitCount;
    ubyte XBitCount;
    ubyte YBitCount;
    ubyte ZBitCount;
    ubyte WBitCount;
    ubyte XBitEnd;
    ubyte YBitEnd;
    ubyte ZBitEnd;
    ubyte WBitEnd;
    short unk;
    short unk;
    float ScaleX;
    float ScaleY;
    float ScaleZ;
    float ScaleW;
    float OffsetX;
    float OffsetY;
    float OffsetZ;
    float OffsetW;
} ElementBitLayoutDefinition;

typedef struct
{
    byte NameID;
    byte FlexOffset;
    byte ElementCount;
    CELL_GCM_VERTEX_TYPE Type;
} FlexElementDef;

typedef struct
{
    byte ElementCount;
    byte ElementCount2;
    byte Unk;
    byte Stride;
    int unk;
    int ElementDefsOffset;
    int ElementNamesArrayOffset <format=hex, fgcolor=cRed>;

    FSeek(BasePos + ElementDefsOffset);
    FlexElementDef elementDefs1[ElementCount];
    FlexElementDef elementDefs2[ElementCount2];

    FSeek(BasePos + ElementNamesArrayOffset);
    struct
    {
        int NamesOffsets[ElementCount + ElementCount2] <format=hex, fgcolor=cRed>;
    
        for (j = 0; j < ElementCount + ElementCount2; j++)
        {
            FSeek(BasePos + NamesOffsets[j]);
            String name;
        }
    } ElementNames;

    FSeek(FileSize());
} FlexStructDeclaration;

typedef struct
{
    struct
    {
        char Magic[4];
        int Version;
        int RelocSize <format=hex>;
        int RelocPtr;
        short FormatCount_0x18;
        short UnkCount_0x1C;
        short ElementBitLayoutDefinitionArrayCount_0x20;
        short StructDeclarationCount_0x24;
        int FormatsOffset_0x18 <format=hex, fgcolor=cRed>;
        int UnkOffset_0x1C <format=hex, fgcolor=cRed>;
        int ElementBitLayoutDefinitionArraysOffset_0x20 <format=hex, fgcolor=cRed>;
        int StructDeclarationsOffset_0x24 <format=hex, fgcolor=cRed>;
        int UnkOffset_0x28;
        int Unk;
        int UnkOffset_0x30;
    } Header;
    
    local int i = 0;
    local int j = 0;
    struct
    {
        for (i = 0; i < Header.FormatCount_0x18; i++)
        {
            FSeek(BasePos + Header.FormatsOffset_0x18 + (i * 0x30));
            FlexInfoAndData format;
        }
    } FlexInfos;
    
    struct
    {
        
        for (i = 0; i < Header.ElementBitLayoutDefinitionArrayCount_0x20; i++)
        {
            FSeek(BasePos + Header.ElementBitLayoutDefinitionArraysOffset_0x20 + (i * 0x08));
            struct
            {
                int Length;
                int EntriesOffset <format=hex, fgcolor=cRed>;
    
                FSeek(BasePos + EntriesOffset + (j * 0x10));
                ElementBitLayoutDefinition layout[Length];
    
            } ElementBitLayoutDefinitionArray;
        }
    
        FSeek(FileSize());
    } ElementBitLayoutDefinitions;
    
    struct
    {
        for (i = 0; i < Header.StructDeclarationCount_0x24; i++)
        {
            FSeek(BasePos + Header.StructDeclarationsOffset_0x24 + (i * 0x10));
            FlexStructDeclaration decl;
        }
} FlexStructDeclarations;

} PMSH <comment="Replaces FVF stuff">;