//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: Gran Turismo 5 Model Header
//   Authors: Nenkai#9075
//   Version: 0.1
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

#include "MDL3ModelInfo.bt"
#include "MDL3MaterialMap.bt"
#include "MDL3FVFDefinitions.bt"
#include "MDL3VM.bt"
#include "MDL3ShapeStreaming.bt"
#include "Shaders.bt"

BigEndian();

local int max = 0;


typedef struct
{
    short A;
    short B;
    short C;
} Tri;

typedef struct
{
    ushort Flags <bgcolor=cGreen, comment="Removing 0x01 causes massive vertex fuckery">;
    short FVFIndex <fgcolor=cYellow, bgcolor=cGreen>;
    short MaterialIndex <fgcolor=cYellow, bgcolor=cGreen>;
    ushort Unk <bgcolor=cGreen, comment="Wiping did nothing">;
    uint VertCount <fgcolor=cGreen, bgcolor=cGreen>;
    uint VerticesOffset <format=hex, fgcolor=cRed, bgcolor=cGreen>;
    uint Unk <bgcolor=cGreen>;
    uint TriLength <fgcolor=cGreen, bgcolor=cGreen>;
    uint TriOffset <format=hex, fgcolor=cRed, bgcolor=cGreen, comment="Giving an offset in shapestream course: nothing happens">;
    uint Unk <bgcolor=cGreen>;
    if (Header.VersionMajor < 10)
    {
        ushort Unk <comment="version < 10", bgcolor=cGreen>;
        short UnkIndex <comment="version < 10", bgcolor=cGreen>;   
    }
    else
    {
        uint UnkOffset <format=hex, fgcolor=cRed, comment="Confirmed offset, version >= 10", bgcolor=cGreen>;
    }
    ushort Unk <bgcolor=cGreen>;
    ushort TriCount <fgcolor=cGreen, bgcolor=cGreen>;
    uint BoundaryBoxOffset <format=hex, fgcolor=cRed, bgcolor=cGreen>;
    uint UnkOffset <format=hex, fgcolor=cRed, comment="Confirmed offset", bgcolor=cGreen>;

    /*
    local int vertexLen = mdl3.FVFDefMap.Def[FVFIndex].DataLength;

    local int cPos = FTell();
    FSeek(BasePos + VerticesOffset);
    byte VerticesData[vertexLen * VertCount] <bgcolor=cBlue>;
    FSeek(cPos);

    FSeek(BasePos + TriOffset);
    short Indices[TriCount * 3] <bgcolor=cGray>;
    FSeek(cPos);*/
    /* 
      if ((Flags & 0x4000) != 0x0) {
        Flags = Flags & 0xe000 | (ushort)(((Flags & 0xfff) << 0x13) >> 0x13);

      if (Header.Version < 10)
         this[0x7] = 0;
         *(undefined4 *)(param_1 + 0x20) = 0x0;
         uVar2 = (uint)(*(ushort *)param_1 >> 0x4) << 0x4;
         uVar1 = (ushort)uVar2 | (ushort)(((*(ushort *)param_1 & 0x1) << 0x1c) >> 0x1c);
         *(ushort *)param_1 = uVar1;
         if ((uVar2 & 0x800) != 0x0) {
           *(ushort *)param_1 = uVar1 | 0x8;
    */

} Mesh <comment="Mapped at FUN_008e7dac">;

typedef struct
{
    int DataOffset <format=hex, fgcolor=cRed>;
    FSeek(BasePos + DataOffset);
    
    struct
    {
        uint KeyNameOffset <format=hex, fgcolor=cRed>;
        ushort Unk;
        ushort Unk2;

        if (KeyNameOffset != 0)
        {
            FSeek(BasePos + KeyNameOffset);
            string Name;
        }
    } Key;
} KeyDef;

typedef struct
{
    short Count1;
    short Count2;
    int empty[3];
    int UnkOffset <format=hex, fgcolor=cRed>;
} Unk0x74;
    
BigEndian();
struct MDL3
{   
    FSeek(0x280);
    local int BasePos = FTell();
    struct
    {
        char Magic[4];
        int Unk <fgcolor=cGreen>;
        int RelocPtr;
        short VersionMajor;
        short RuntimeFlags <comment="Set at runtime, ignore">;

       ushort ModelCount <fgcolor=cGreen>;
       ushort Count0x34 <fgcolor=cGreen>;
       ushort MeshesCount <fgcolor=cGreen>;
       ushort Count0x3C <fgcolor=cGreen>;
       ushort FVFCount <fgcolor=cGreen>;
       ushort BonesCount <fgcolor=cGreen>;
       ushort SizeFor0x68;
       ushort VMVariablesCount <fgcolor=cGreen>;
       ushort Unk;
       ushort Count0x5C <fgcolor=cGreen>;
       ushort Unk;
       ushort Count0x78 <fgcolor=cGreen>;
       ushort Count0xA4 <fgcolor=cGreen>;
       ushort Count0x54 <fgcolor=cGreen, comment="Can be safely wiped? No changes (c053x GT6)">;
       ushort Count0x88 <fgcolor=cGreen>;
       ushort Unk;
       uint ModelInfoOffset <format=hex, fgcolor=cRed, comment="0x30 Stride">;
       uint Offset0x34 <format=hex, fgcolor=cRed, comment="0x08 Stride">;
       uint MeshesMapOffset <format=hex, fgcolor=cRed, comment="0x30 Stride">;
       uint Offset0x3C <format=hex, fgcolor=cRed, comment="0x08 Stride">;
       uint FVFOffset <format=hex, fgcolor=cRed, comment="0x78 Stride">;
       uint MaterialsOffset <format=hex, fgcolor=cRed, comment="Always 1 entry, 0x18 Stride">;
       uint TextureSetOffset <format=hex, fgcolor=cRed, comment="Alone">;
       uint ShadersOffset <format=hex, fgcolor=cRed, comment="Own component">;
       uint BonesOffset <format=hex, fgcolor=cRed, comment="0x48 Stride">;
       uint UnkKeyMap0x54 <format=hex, fgcolor=cRed, comment="0x4 Stride">;
       uint VMVariablesOffset <format=hex, fgcolor=cRed, comment="0x8 Stride">;
       uint Offset0x5C <format=hex, fgcolor=cRed, comment="0x8 Stride">;
       uint VMCommandsOpcodesLength <format=hex, fgcolor=cGreen>;
       uint VMCommandsOffset <format=hex, fgcolor=cRed, comment="Possibly own thing, opcodes for animations">;
       uint Offset0x68 <format=hex, fgcolor=cRed, comment="Possibly own thing">;
       uint RelocSize <format=hex>;
       uint PossiblyEmpty;
       uint RuntimeValue <comment="Set to 0 after mapping">;
       uint Offset0x78 <format=hex, fgcolor=cRed, comment="0x14 Stride">;
       uint PossiblyEmpty;
       uint PossiblyEmpty;
       ushort UnkIndex <comment="Set to -1 at runtime if Version > 4">;
       ushort UnkIndex <comment="Set to -1 at runtime if Version > 4">;
       uint Offset0x88 <format=hex, fgcolor=cRed, comment="0x28 Stride, points to a map already discovered in materials">;
       short Unk0x8C;
       ushort ImageMetadataKeyMapCount <fgcolor=cGreen>;
       uint ImageMetadataKeyMapOffset <format=hex, fgcolor=cRed, comment="0x8 Stride">;
       uint PossiblyEmpty;
       ushort Count0x9C <comment="If VersionMajor < 7">;
       ushort Count0xA0;
       uint Offset0x9C <format=hex, fgcolor=cRed, comment="If VersionMajor < 7, 0x80 Stride">;
       uint Offset0xA0 <format=hex, fgcolor=cRed, comment="0x8 Stride">;
       uint Offset0xA4 <format=hex, fgcolor=cRed, comment="0x4 Stride">;
       uint PossiblyEmpty;
       uint ShapeStreamingMapOffset <format=hex, fgcolor=cRed, comment="If VersionMajor > 1, always 1 entry, Stride 0x20">;
       uint Offset0xB0 <format=hex, fgcolor=cRed, comment="If VersionMajor > 1, Stride 0x40">;
       uint Unk <comment="Needs checking">;
       uint Offset0xB8 <format=hex, fgcolor=cRed, comment="If VersionMajor > 2, Own thing">;
       uint VMContextOffset <format=hex, fgcolor=cRed, comment="If VersionMajor > 5, always 1 entry, Stride 0x20">;
       uint Offset0xC0 <format=hex, fgcolor=cRed, comment="If VersionMajor > 5, always 1 entry, Stride 0x20">;
       ushort Count0xC0 <fgcolor=cGreen, comment="If VersionMajor > 5">;
       ushort PossiblyEmpty;
       short Unk;
       short Count0xCC <fgcolor=cGreen, comment="If VersionMajor > 8">;
       uint Offset0xCC <format=hex, fgcolor=cRed, comment="If VersionMajor > 8">;
       uint Offset0xD0 <format=hex, fgcolor=cRed, comment="Own Thing, If VersionMajor > 8">;
       uint PMSHOffset <format=hex, fgcolor=cRed, comment="Own Thing, If VersionMajor > 8">;
       uint CarBodyStreamOffset <format=hex, fgcolor=cRed, comment="Own Thing, If VersionMajor > 13">;
        
    } Header <bgcolor=cPurple>;

    FSeek(BasePos);
    struct ModelInfoMap
    {
        local int i = 0;
        for (i = 0; i < Header.ModelCount; i++)
        {
            FSeek(BasePos + Header.ModelInfoOffset + (i * 0x30));
            ModelInfo modelInfo;
        }
    } modelInfoMap;
    
    if (Header.MaterialsOffset != 0)
    {
        FSeek(BasePos + Header.MaterialsOffset);
        MaterialMap Materials;
    }

    FSeek(BasePos + Header.MeshesMapOffset);
    Mesh meshes[Header.MeshesCount];

    if (Header.FVFCount > 0)
    {
        local int i = 0;
        struct FVFDefinitionMap
        {
            for (i = 0; i < Header.FVFCount; i++)
            {
                FSeek(BasePos + Header.FVFOffset + (i * 0x78));
                FVFDefinition Def;
            }
            
        } FVFDefMap;
    }


    FSeek(BasePos + Header.TextureSetOffset);
    TXS3 TextureSet (BasePos);

    if (Header.ShadersOffset != 0) 
    {
        FSeek(BasePos + Header.ShadersOffset);
        Shaders shaders;
    }
    if (Header.Count0x54 > 0)
    {
        FSeek(BasePos + Header.UnkKeyMap0x54 + (i * sizeof(uint)));
        KeyDef def <comment="Seemingly not used">;
    }

    if (Header.VMVariablesCount > 0)
    {
        struct
        {
            for (i = 0; i < Header.VMVariablesCount; i++)
            {
                FSeek(BasePos + Header.VMVariablesOffset + (i * 0x08));
                ImageMetadataKey key;
            }
        } VMVariablesMap;
    }
    
    if (Header.VMCommandsOpcodesLength > 0)
    {
        FSeek(BasePos + Header.VMCommandsOffset);
        byte VMCommandsPayload[Header.VMCommandsOpcodesLength] <bgcolor=cBlack>;
    }

    if (Header.VMContextOffset > 0)
    {
        FSeek(BasePos + Header.VMContextOffset);
        VMContext vmContext;
    }

    if (Header.Offset0x78 > 0)
    { 
         FSeek(BasePos + Header.Offset0x78);
         struct 
         { 
             short UnkA;
             short UnkB;
             int empty;
             int empty;
             int empty;
             int EmptyStorageOffset <format=hex>;
         } Unk0x78Entry[Header.Count0x78];
    }

    if (Header.ImageMetadataKeyMapCount > 0)
    {
        struct
        {
            for (i = 0; i < Header.ImageMetadataKeyMapCount; i++)
            {
                FSeek(BasePos + Header.ImageMetadataKeyMapOffset + (i * 0x08));
                ImageMetadataKey key;
            }
        } ImageKeyMap <comment="We already go through those in materials">;
    }

    if (Header.ShapeStreamingMapOffset > 0)
    {
        FSeek(BasePos + Header.ShapeStreamingMapOffset);
        UnkMap0xAC ShapeStreamingMap;
    }

    Printf("%d", max);
    return;
    
} mdl3;
