//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: Gran Turismo PS2 - Model Set
//   Authors: Nenkai#9075
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

BitfieldDisablePadding();

local byte stop = false;

typedef struct
{
    byte nextSize;

    /* 800000 = Unk
     * 800001 = Model Namen or "useOldLOD" for MultiSkinModel
     * 800002 = Brake Offset as float
    */
    int ID : 24 <format=hex>;
        
    if (nextSize == 0xFF || ID == 0)
    {
        stop = true;
        return;
    }   

    local int dataLen = nextSize * 4;
    byte data[nextSize * sizeof(int)];
} ExtensionData <optimize=false>;

typedef struct
{
    while (true)
    {
        ExtensionData ext;
        if (stop)
            break;
    }

} ExtensionMap;

typedef struct
{
    // 0x8000 = Vertices
    // 0x8040 = UVs
    // 0x8080 = Normals
    // 0xC0C0 - First value byte = vert count
    // Anything else doesn't seem related to faces

    ushort vuaddr <format=hex>;
    byte num : 8;
    enum <byte>
    {
        NOP = 0x00,
        STCYCL = 0x01,
        OFFSET = 0x02,
        BASE = 0x03,
        ITOP = 0x04,
        STMOD = 0x05,
        MSKPATH3 = 0x06,
        MARK = 0x07,
        FLUSHE = 0x10,
        FLUSH = 0x11,
        FLUSHA = 0x13,
        MSCAL = 0x14,
        MSCALF = 0x15,
        MSCNT = 0x17,
        STMASK = 0x20,
        STROW = 0x30,
        STCOL = 0x31,
        MPG = 0x4A,
        DIRECT = 0x50,
        DIRECTHL = 0x51,
        UNPACK = 0x60,
    } cmd : 7 <format=hex>;
    byte irq : 1;

    if ((cmd >= 0x60))
    {
        struct
        {
            local int field_type = cmd & 0x03;
            local int elem_count = ((cmd >> 2) & 0x03) + 1;

            switch (field_type)
            {
                case 0:
                    int val[elem_count] <optimize=false>;
                    break;
    
                case 1:
                    short val[elem_count] <optimize=false>;
                    break;
    
                case 2:
                    byte val[elem_count] <optimize=false>;
                    break;
    
                //case 3:
                //    int val : 5;
                //    break;
            }

            
 
        } UNPACK_DATA[num] <optimize=false>;

        FSkip(FTell() % 4);
    }

} VifCommand <optimize=false>;
typedef struct
{
    local int count = 0;
    while (true)
    {
        VifCommand cmd;
        if (cmd[count++].cmd == 0)
            break;
    }

} VifData <optimize=false, bgcolor=cBlack>;

typedef struct 
{
    local int baseShapePos = FTell();
    int RelocPtr;
    float Size;
    byte unk : 5; // 2 to 6 are handled specifically
    byte unk : 3;

    byte unkFlags <format=hex>;
    short VifPartCount;
    short TotalVertCount;
    short TriangleCount;

    struct
    {
        int VifDataOffset <format=hex, fgcolor=cRed>;
        short Size0x10Strides;
        short Unk2;
    } ShapeDataInfo[VifPartCount];

    local int j = 0;
    for (j = 0; j < VifPartCount; j++)
    {
        FSeek(BasePos + baseShapePos + ShapeDataInfo[j].VifDataOffset);
        VifData vif;
    }
} Shape <optimize=false>;

typedef struct
{
    enum<byte> 
    {
        EndTerminator = 0,

        pgluCallShape = 4,
        Unk = 6,
        LODData = 7,
        Seek = 8,
        Unk9 = 9,
        pglEnable_4 = 0x1A,
        pglDisable_4 = 0x1b,
        pglAlphaFunc1ub = 0x1c,
        pglEnable_3 = 0x1D,
        pglDisable_3 = 0x1E,
        pglDestinationAlphaFunc = 0x1F,
        pglBlendFunc1ub = 0x20,
        pglFogColor1ui = 0x21,
        pgluColor = 0x22,
        pglFogColor1ui2 = 0x23,
        pglDepthMask_0Disable = 0x25,
        pglDepthMask_1Enable = 0x26,
        pgluCacheTexSetPath3 = 0x2b,
        externalTexSet = 0x50,

    }type;

    if (type == 0)
    {
        stop = true;
        return;
    }

    if (type == 4)
    {
        byte shapeIndex <comment="To Shape Map">;
    }
    if (type == 6)
    {
        short unk;
        byte unkCount;
        short unks[unkCount]  <format=hex>;
    }
    else if (type == 7)
    {
        byte data[0x10];
        byte lodCount;
        short unkOffsets[lodCount] <format=hex>;
    }
    else if (type == 8)
    {
        byte offsetFromHere <format=hex>;
    }
    else if (type == 9)
    {
        short unkOffset <format=hex>;
    }
    else if (type == 0x1c)
    {
        byte unk;
        byte unk2;
    }
    else if (type == 0x1f)
    {
        byte unk;
    }
    else if (type == 0x20)
    {
        byte unk;
        byte unk2;
    }
    else if (type == 0x21)
    {
        uint color;
    }
    else if (type == 0x2b)
    {
        byte textureIndex;
    }
    else if (type == 0x50)
    {
        byte externalTexSetIndex;
    }
    


} Inst <optimize=false>;

typedef struct
{
    while (true)
    {
        Inst ext;
        if (stop)
            break;
    }

} InstMap;

typedef struct 
{
    byte unk;
    byte unkAlways8;
    byte unk;
    byte unk;
    int unk <format=hex>;
    float usedToComputeModelLODWidth;
    float usedToComputeBounds;
    int e;
    int f;
    int SetupOpcodesOffset <format=hex>;
    int h;
    int j;
    int k;

    FSeek(BasePos + SetupOpcodesOffset);
    //InstMap map;
    

} Model;

struct GT4_ModelSet
{   

    local int BasePos = FTell();
    struct
    {
        
        char Magic[4];
        int a;
    
        FSeek(BasePos + 0x10);
        int fileSize <format=hex>;
    
        FSeek(BasePos + 0x16);
        short ModelsCount;
        short ShapeCount;
        short Unk;
        short texSetArrayWidth;
        short texSetArrayHeight;
        short countFor0x4C;
        short empty;
        short hostMethodInfoCount;
        short registerDataCount;
        short outRegisterInfoCount;
    
        FSeek(BasePos + 0x2a);
        short modelSetSymbols;
        byte unkColorIndex;
        byte unkColorIndex2;
        short bindMatrixCount;
        
        FSeek(BasePos + 0x36);
        short unkCount; // Negative, intentional
        int ModelsOffset <format=hex>; // Strides of 0x28, count at 0x16
        int ShapesOffset <format=hex>; // Strides of 0x4 - offsets
    
        FSeek(BasePos + 0x40);
        int matTable <format=hex>;
        int texSetsOffset <format=hex>;
        int bindMatrixMapOffset <format=hex>;
        int hostMethodInfoOffset <format=hex>; // strides of 0x08
    
        FSeek(BasePos + 0x50);
        int registerInfoOffset <format=hex>;
        int outRegisterInfoOffset <format=hex>;
        int modelSetSymbolsOffset <format=hex>; // 0x08 toc - offset then index?
        
        FSeek(BasePos + 0x60);
        int unkColorsArrayOffset;
    
        FSeek(BasePos + 0x68);
        int ExtensionDataOffset <format=hex>;
    } Header;

    FSeek(BasePos + Header.ModelsOffset);
    Model models[Header.ModelsCount];

    FSeek(BasePos + Header.ShapesOffset);
    struct
    {
        int ShapesOffset[Header.ShapeCount] <format=hex, fgcolor=cRed>;

        local int i = 0;
        for (i = 0; i < Header.ShapeCount; i++)
        {
            FSeek(BasePos + ShapesOffset[i]);
            Shape shape;   
        }
    } Shapes;

    FSeek(BasePos + Header.ExtensionDataOffset);
    ExtensionMap extensionMap;

} MDLS <optimize=false>;