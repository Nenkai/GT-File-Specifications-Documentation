//------------------------------------------------
//--- 010 Editor v10.0.2 Binary Template
//
//      File: Gran Turismo PS2 - Model Set
//   Authors: Nenkai#9075
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

BitfieldDisablePadding();

local byte stop = false;

typedef struct
{
    float X;
    float Y;
    float Z;
} Vector3;

typedef struct
{
    local int firstByte = ReadByte();
    if (firstByte & 0x80)
    {
        if (firstByte & 0x40)
        {
            byte values[4];
        }
        else
        {
            byte values[2];
        }
    }
    else
    {
        byte value;
    }
} _7bitInt <optimize=false>;
typedef struct
{
    byte nextSize;

    /* 800000 = Unk
     * 800001 = Model Namen or "useOldLOD" for MultiSkinModel
     * 800002 = Brake Offset as float
    */
    int ID : 24 <format=hex>;
        
    if (nextSize == 0xFF || ID == 0)
    {
        stop = true;
        return;
    }   

    local int dataLen = nextSize * 4;
    byte data[nextSize * sizeof(int)];
} ExtensionData <optimize=false>;

typedef struct
{
    while (true)
    {
        ExtensionData ext;
        if (stop)
            break;
    }

} ExtensionMap;

uint AlignValue(uint x, uint alignment)
{
      local uint mask = ~(alignment - 1);
      return (x + (alignment - 1)) & mask;
}

typedef enum<int> SCE_GS_PRIM
{
    SCE_GS_PRIM_POINT		= (0x00),
    SCE_GS_PRIM_LINE		= (0x01),
    SCE_GS_PRIM_LINESTRIP   = (0x02),
    SCE_GS_PRIM_TRI			= (0x03),
    SCE_GS_PRIM_TRISTRIP	= (0x04),
    SCE_GS_PRIM_TRIFAN		= (0x05),
    SCE_GS_PRIM_SPRITE		= (0x06),
    SCE_GS_PRIM_IIP			= (1<<3), // Gouraud
    SCE_GS_PRIM_TME			= (1<<4), // Textured
    SCE_GS_PRIM_FGE			= (1<<5), // Fogging
    SCE_GS_PRIM_ABE			= (1<<6), // Alpha Blending
    SCE_GS_PRIM_AA1			= (1<<7), // Anti-Aliasing
    SCE_GS_PRIM_FST			= (1<<8), // Use ST for texture coords
    SCE_GS_PRIM_CTXT1		= (0),    // Context
    SCE_GS_PRIM_CTXT2		= (1<<9),
    SCE_GS_PRIM_FIX			= (1<<10), // Fragment Control
} SceGsPrim;

typedef enum<byte> SCE_GIF_FLAGS
{
   SCE_GIF_PACKED      = 0,
   SCE_GIF_REGLIST     = 1,
   SCE_GIF_IMAGE       = 2,
   // Maybe more
} SceGsFlags;

string PrintPrimInfo(SCE_GS_PRIM& as)
{
   local string s;
   if ((as & 0b111) == 1)
      s += "SCE_GS_PRIM_LINE | ";
   else if ((as & 0b111) == 2)
      s += "SCE_GS_PRIM_LINESTRIP | ";
   else if ((as & 0b111) == 3)
      s += "SCE_GS_PRIM_TRI | ";   
   else if ((as & 0b111) == 4)
      s += "SCE_GS_PRIM_TRISTRIP | ";
   else if ((as & 0b111) == 5)
      s += "SCE_GS_PRIM_TRIFAN | ";
   else if ((as & 0b111) == 6)
      s += "SCE_GS_PRIM_SPRITE | ";
   else
      s += "SCE_GS_PRIM_POINT | ";

   if ((as >> 3) & 1)
      s += "SCE_GS_PRIM_IIP (Gouraud) | ";

   if ((as >> 4) & 1)
      s += "SCE_GS_PRIM_TME (Textured) | ";
   
   if ((as >> 5) & 1)
      s += "SCE_GS_PRIM_FGE (Fogging) | ";

   if ((as >> 6) & 1)
      s += "SCE_GS_PRIM_ABE (Alpha Blending) | ";
  
   if ((as >> 7) & 1)
      s += "SCE_GS_PRIM_AA1 (Anti-Aliasing) | ";

   if ((as >> 8) & 1)
      s += "SCE_GS_PRIM_FST (Use ST for texture coords) | ";

   if ((as >> 9) & 1)
      s += "SCE_GS_PRIM_CTXT2 | ";

   if ((as >> 10) & 1)
      s += "SCE_GS_PRIM_FIX (Fragment Control) | ";

   return s;
}

typedef struct
{
    // 0xC0C0 - GIFTag? Second value = SCE_GIF_SET_TAG
    // 0x8000 = Vertices
    // 0x8040 = UVs
    // 0x8080 = Normals
    
    // Anything else doesn't seem related to faces

    ushort vuaddr <format=hex>;
    byte num : 8;
    enum <byte>
    {
        NOP = 0x00,
        STCYCL = 0x01,
        OFFSET = 0x02,
        BASE = 0x03,
        ITOP = 0x04,
        STMOD = 0x05,
        MSKPATH3 = 0x06,
        MARK = 0x07,
        FLUSHE = 0x10,
        FLUSH = 0x11,
        FLUSHA = 0x13,
        MSCAL = 0x14,
        MSCALF = 0x15,
        MSCNT = 0x17,
        STMASK = 0x20,
        STROW = 0x30,
        STCOL = 0x31,
        MPG = 0x4A,
        DIRECT = 0x50,
        DIRECTHL = 0x51,
        UNPACK = 0x60,
    } cmd : 7 <format=hex>;

    // MSCAL is always appended to the end (engine side)

    byte irq : 1;

    if (vuaddr == 0xC0C0)
    {
        struct
        {
            int nloop : 15 <comment="Data per register to transfer">;
            int eop : 1 <comment="End of packet">;
            int pad16 : 16;
            int id : 14;
            int pre : 1;
            SceGsPrim prim : 11 <comment=PrintPrimInfo>;
            SCE_GIF_FLAGS flg : 2;
            int nreg : 4 <comment="Number of registers">;
        } sceGifTag;
        int registerList <format=hex>; // Refer to https://psi-rockin.github.io/ps2tek/#gifdataformats
    }
    else if ((cmd >= 0x60))
    {
        struct
        {
            local int field_type = cmd & 0x03;
            local int elem_count = ((cmd >> 2) & 0x03) + 1;

            switch (field_type)
            {
                case 0:
                    int val[elem_count] <optimize=false>;
                    break;
    
                case 1:
                    short val[elem_count] <optimize=false>;
                    break;
    
                case 2:
                    byte val[elem_count] <optimize=false>;
                    break;
    
                //case 3:
                //    int val : 5;
                //    break;
            }

            
 
        } UNPACK_DATA[num] <optimize=false>;
    }
    else if (cmd == STMASK)
    {
        uint mask <format=hex>;
    }
    else if (cmd == STROW)
    {
        uint strow[4];
    }
    FSeek(AlignValue(FTell(), 4));

} VifCommand <optimize=false>;


typedef struct(int quadwordSize)
{
    local int count = 0;
    local int basePos = FTell();
    while (FTell() < basePos + (quadwordSize * 0x10))
    {
        VifCommand cmd;
    }

} VifData <optimize=false, bgcolor=cBlack>;

typedef struct 
{
    local int baseShapePos = FTell();
    int RelocPtr;
    float Size;
    byte unk0 : 5; // 2 to 6 are handled specifically
    byte unk1 : 3;

    if (unk0 != 5)
        Printf("%d\n", unk0);
    byte unkFlags <format=hex>;
    short VifPartCount;
    short TotalVertCount;
    short TriangleCount;

    struct
    {
        int VifDataOffset <format=hex, fgcolor=cRed>;
        short DMATagQuadwordCount;

        // GT4O 0x59A7E8 -> 0x599DB8
        short pgluMaterialFunc_TextureIndex : 9; // 511 max
        short pgluMaterialFuncValue2 : 7; // 127 max
    } ShapeDataInfo[VifPartCount];

    local int j = 0;
    for (j = 0; j < VifPartCount; j++)
    {
        FSeek(baseShapePos + ShapeDataInfo[j].VifDataOffset);
        VifData vif(ShapeDataInfo[j].DMATagQuadwordCount);
    }

    if (unkFlags & 0x80)
    {
        float unk;
        ubyte VertCount;
        ubyte VUAddrQWord <format=hex>;

    }
} Shape <optimize=false>;

typedef struct
{
    enum<byte> 
    {
        End = 0,

        RenderModel_1ub = 2,
        RenderModel_1us = 3,
        pgluCallShape = 4,
        Unk = 6,
        LODData = 7,
        Jump = 8,
        Unk9 = 9,
        pglUnk_Enable17_WithMatrix = 10,
        pglUnk_Enable17 = 11,
        pglPushMatrix = 12,
        pglPopMatrix = 13,
        pglMatrixMode = 14,
        pglScale = 18,
        pglEnable_4 = 0x1A,
        pglDisable_4 = 0x1b,
        pglAlphaFunc_1ub = 28,
        pglEnable_3 = 29,
        pglDisable_3 = 30,
        pglDestinationAlphaFunc = 31,
        pglBlendFunc1ub = 32,
        pglFogColor1ui = 33,
        pgluColor = 34,
        pglFogColor1ui2 = 35,
        pglDepthMask_0Disable = 37,
        pglDepthMask_1Enable = 38,
        pgluTexTable_1ub = 43,
        pglAlphaFail = 47,
        externalTexSet = 0x50,

    }type;

    if (type == 0)
    {
        stop = true;
        return;
    }

    if (type == 4)
    {
        byte shapeIndex <comment="To Shape Map">;
    }
    if (type == 6)
    {
        short unk;
        byte unkCount;
        short unks[unkCount]  <format=hex>;
    }
    else if (type == 7)
    {
        byte data[0x10];
        byte lodCount;
        short unkOffsets[lodCount] <format=hex>;
    }
    else if (type == Jump)
    {
        byte offsetFromHere <format=hex>;
    }
    else if (type == 9)
    {
        short unkOffset <format=hex>;
    }
    else if (type == pglUnk_Enable17_WithMatrix)
    {
        byte unkCount;
        Vector3 vecs[unkCount];
        short unk;
    }
    else if (type == 18)
    {
        Vector3 Scale;
    }
    else if (type == pglAlphaFunc_1ub)
    {
        byte Func;
        ubyte Ref;
    }
    else if (type == 0x1f)
    {
        byte unk;
    }
    else if (type == 0x20)
    {
        byte unk;
        byte unk2;
    }
    else if (type == 0x21)
    {
        uint color;
    }
    else if (type == pgluTexTable_1ub)
    {
        byte IndexToFirstMapInTex1; // pgluCacheTexSetPath3 + pgluTexTable
    }
    else if (type == pglAlphaFail)
    {
        byte val;
    }
    else if (type == 80)
    {
        byte externalTexSetIndex;
    }
    


} Inst <optimize=false>;

typedef struct
{
    while (true)
    {
        Inst ext;
        if (stop)
            break;
    }

} InstMap;

typedef struct 
{
    byte unk;
    byte BoundCount;
    byte unk;
    byte unk;
    int BoundsOffset <format=hex, fgcolor=cRed>;
    float usedToComputeModelLODWidth;
    float usedToComputeBounds;
    float e;
    int f;
    int SetupOpcodesOffset <format=hex>;
    int h;
    int j;
    int k;

    FSeek(BasePos + SetupOpcodesOffset);
    InstMap map;
    

} Model;


struct GT4_ModelSet
{   

    local int BasePos = FTell();
    struct
    {
        
        char Magic[4];
        int RelocatorDataOffset <format=hex>;
        int RelocatorDataSize <format=hex>;
        int RelocationBase;

        FSeek(BasePos + 0x10);
        int fileSize <format=hex>;
        byte Unk;
        byte HasInstanceAt0x7C <format=hex>;

        short ModelsCount;
        short ShapeCount;
        short Unk;
        short texSetArrayWidth;
        short texSetArrayHeight;
        short countFor0x4C;
        short empty;
        short hostMethodInfoCount;
        short registerDataCount;
        short outRegisterInfoCount;
    
        FSeek(BasePos + 0x2a);
        short modelSetSymbols;
        byte unkColorIndex;
        byte unkColorIndex2;
        short bindMatrixCount;
        
        FSeek(BasePos + 0x36);
        short unkCount; // Negative, intentional
        int ModelsOffset <format=hex>; // Strides of 0x28, count at 0x16
        int ShapesOffset <format=hex>; // Strides of 0x4 - offsets
    
        FSeek(BasePos + 0x40);
        int matTable <format=hex>;
        int texSetsOffset <format=hex>;
        int bindMatrixMapOffset <format=hex>;
        int hostMethodInfoOffset <format=hex>; // strides of 0x08
    
        FSeek(BasePos + 0x50);
        int registerInfoOffset <format=hex>;
        int outRegisterInfoOffset <format=hex>;
        int modelSetSymbolsOffset <format=hex>; // 0x08 toc - offset then index?
        
        FSeek(BasePos + 0x60);
        int unkColorsArrayOffset;
    
        FSeek(BasePos + 0x68);
        int ExtensionDataOffset <format=hex>;
    } Header;

    FSeek(BasePos + Header.ModelsOffset);
    Model models[Header.ModelsCount];

    FSeek(BasePos + Header.ShapesOffset);
    struct
    {
        int ShapesOffset[Header.ShapeCount] <format=hex, fgcolor=cRed>;

        local int i = 0;
        for (i = 0; i < Header.ShapeCount; i++)
        {
            FSeek(BasePos + ShapesOffset[i]);
            Shape shape;   
        }
    } Shapes;

    FSeek(BasePos + Header.ExtensionDataOffset);
    ExtensionMap extensionMap;

    FSeek(Header.RelocatorDataOffset);
    struct
    {
        int OffsetToUserData;
        uint SymbolsPtr <comment="This is not read">;
        _7bitInt OffsetType; // 0 = SetRelocationBase, 1 = update1/byte, 2 = update2/short, 3 = update4/int
        _7bitInt SymbolIndex;
        _7bitInt TotalNumberOfOffsetsToRelocate;
        _7bitInt StartOffsetForGroup;

        local int stop = false;
        while (!stop)
        {
            struct
            {
                ubyte CountAndFlag <format=hex>;
                if (CountAndFlag == 0)
                {
                    stop = true;
                    break;
                }

                if (CountAndFlag >= 0x80) // Array, all in a row
                {
                    // Array, all in a row
                    local int i = 0;
                    local int OffsetCount = CountAndFlag - 0x80;
                    _7bitInt OffsetsToUpdateNext[OffsetCount - 1];
                    break;
                }
                else // Array with provided offsets
                {
                    _7bitInt NextOffsets[CountAndFlag + 1];
                    break;
                }
            } RelocateOffsetGroup;
            
        }

        // Child offsets
        
        FSeek(Header.RelocatorDataOffset + OffsetToUserData);
        int SymbolCount1 <comment="Debug or stripped">;

        int SymbolCount2 <comment="Debug or stripped">;
        if (SymbolCount1 && SymbolCount2)
        {
            // readUserChunks(i, count1, count2) - stripped in release
            ushort unkCount;

            // Masked strings are xorred by 0xAA
            // string uint masked_symbols_string_offsets[unkCount]
        }
    } RelocatorData;
} MDLS <optimize=false>;
